#!/usr/bin/env bash
# ============================================================================
# gummyworm - Transform images into glorious ASCII art! üêõ
# ============================================================================
# A playful, feature-rich image-to-ASCII converter
#
# Usage: gummyworm [OPTIONS] <image_file>
#
# For help: gummyworm --help
# ============================================================================

# Strict mode
set -euo pipefail

# ============================================================================
# Initialization
# ============================================================================

# Determine script location and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Support both installed (bin/) and development layouts
if [[ -d "$SCRIPT_DIR/../lib" ]]; then
    # Running from bin/ directory
    GUMMYWORM_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
elif [[ -d "$SCRIPT_DIR/lib" ]]; then
    # Running from project root
    GUMMYWORM_ROOT="$SCRIPT_DIR"
else
    echo "Error: Cannot find gummyworm lib directory" >&2
    exit 1
fi

export GUMMYWORM_ROOT

# ============================================================================
# Load Modules
# ============================================================================

# shellcheck source=lib/config.sh
source "${GUMMYWORM_ROOT}/lib/config.sh"

# shellcheck source=lib/utils.sh
source "${GUMMYWORM_ROOT}/lib/utils.sh"

# shellcheck source=lib/palettes.sh
source "${GUMMYWORM_ROOT}/lib/palettes.sh"

# shellcheck source=lib/image.sh
source "${GUMMYWORM_ROOT}/lib/image.sh"

# shellcheck source=lib/converter.sh
source "${GUMMYWORM_ROOT}/lib/converter.sh"

# shellcheck source=lib/cli.sh
source "${GUMMYWORM_ROOT}/lib/cli.sh"

# shellcheck source=lib/export.sh
source "${GUMMYWORM_ROOT}/lib/export.sh"

# ============================================================================
# Cleanup
# ============================================================================

# Ensure temp files are cleaned up on exit (especially stdin temp)
cleanup() {
    if [[ -n "${ARG_STDIN_TEMP:-}" ]]; then
        rm -f "$ARG_STDIN_TEMP"
    fi
}
trap cleanup EXIT

# ============================================================================
# Helper Functions
# ============================================================================

# Get content for export, re-converting with color if needed for graphical formats
# Usage: get_export_content <format> <plain_result> <image> <width> <height> <palette> <invert> <color> <preserve_aspect> [truecolor]
# Output: Content suitable for the export format
get_export_content() {
    local format="$1"
    local plain_result="$2"
    local image="$3"
    local width="$4"
    local height="$5"
    local palette="$6"
    local invert="$7"
    local color="$8"
    local preserve_aspect="$9"
    local truecolor="${10:-false}"
    
    # For graphical formats without color, re-convert with color enabled
    # Always use truecolor for graphical exports (full RGB support)
    if [[ "$format" =~ $RE_GRAPHICAL_FORMAT && "$color" != "true" ]]; then
        convert_to_ascii "$image" "$width" "$height" "$palette" "$invert" "true" "$preserve_aspect" "true"
    else
        echo -e "$plain_result"
    fi
}

# ============================================================================
# Main Function
# ============================================================================

main() {
    # Check dependencies
    image_check_deps
    
    # Parse command line arguments
    parse_args "$@"
    
    # Auto-detect truecolor support if not explicitly set
    # Check $COLORTERM environment variable for 'truecolor' or '24bit'
    if [[ "$ARG_TRUECOLOR" != "true" && "$ARG_COLOR" == "true" ]]; then
        if detect_truecolor_support; then
            ARG_TRUECOLOR="true"
            [[ "$ARG_QUIET" != "true" ]] && log_debug "Auto-detected true color support"
        fi
    fi
    
    # Resolve palette once (shared across all images)
    local palette
    if palette_exists "$ARG_PALETTE"; then
        palette=$(palette_get "$ARG_PALETTE")
    else
        # Treat as custom inline palette
        palette="$ARG_PALETTE"
    fi
    
    # Validate palette
    palette_validate "$palette" || exit 1
    
    # Batch processing statistics
    local total_images=${#ARG_IMAGES[@]}
    local processed=0
    local failed=0
    local failed_files=()
    
    # Show batch info
    if [[ "$ARG_QUIET" != "true" && $total_images -gt 1 ]]; then
        log_info "Processing $total_images images..."
    fi
    
    # Process each image
    for image in "${ARG_IMAGES[@]}"; do
        processed=$((processed + 1))
        
        # Resolve the actual file (download URL if needed)
        local resolved_image="$image"
        local temp_downloaded=""
        
        if is_url "$image"; then
            if [[ "$ARG_QUIET" != "true" ]]; then
                log_info "Downloading: $image"
            fi
            resolved_image=$(download_image "$image") || {
                log_error "Failed to download: $image"
                failed=$((failed + 1))
                failed_files+=("$image")
                [[ "$ARG_CONTINUE_ON_ERROR" == "true" ]] && continue || exit 1
            }
            temp_downloaded="$resolved_image"
        fi
        
        # Validate image file
        if ! image_is_valid "$resolved_image"; then
            log_error "Invalid image: $image"
            failed=$((failed + 1))
            failed_files+=("$image")
            [[ -n "$temp_downloaded" ]] && rm -f "$temp_downloaded"
            [[ "$ARG_CONTINUE_ON_ERROR" == "true" ]] && continue || exit 1
        fi
        
        # Show progress info (unless quiet)
        if [[ "$ARG_QUIET" != "true" ]]; then
            local dims
            dims=$(image_dimensions "$resolved_image")
            if [[ $total_images -gt 1 ]]; then
                log_info "[$processed/$total_images] Converting: $(basename "$image") (${dims// /x})"
            else
                log_info "Converting: $(basename "$image") (${dims// /x})"
                log_info "Output size: ${ARG_WIDTH} chars wide"
                if [[ "$ARG_COLOR" == "true" ]]; then
                    if [[ "$ARG_TRUECOLOR" == "true" ]]; then
                        log_info "Color mode: true color (24-bit) üé®"
                    else
                        log_info "Color mode: 256-color üé®"
                    fi
                fi
                [[ "$ARG_INVERT" == "true" ]] && log_info "Inverted: yes"
            fi
        fi
        
        # Perform conversion
        local result
        result=$(convert_to_ascii \
            "$resolved_image" \
            "$ARG_WIDTH" \
            "$ARG_HEIGHT" \
            "$palette" \
            "$ARG_INVERT" \
            "$ARG_COLOR" \
            "$ARG_PRESERVE_ASPECT" \
            "$ARG_TRUECOLOR"
        ) || {
            log_error "Conversion failed: $image"
            failed=$((failed + 1))
            failed_files+=("$image")
            [[ -n "$temp_downloaded" ]] && rm -f "$temp_downloaded"
            [[ "$ARG_CONTINUE_ON_ERROR" == "true" ]] && continue || exit 1
        }
        
        # Clean up temp downloaded file
        [[ -n "$temp_downloaded" ]] && rm -f "$temp_downloaded"
        
        # Determine output format (auto-detect from extension if not explicitly set)
        local output_format="$ARG_FORMAT"
        
        # Output results
        if [[ -n "$ARG_OUTPUT_DIR" ]]; then
            # Save to output directory with auto-generated name
            local base_name
            base_name=$(basename "$image")
            
            # Use format-appropriate extension
            local ext
            ext=$(export_get_extension "$output_format")
            base_name="${base_name%.*}.ascii.${ext}"
            local out_file="$ARG_OUTPUT_DIR/$base_name"
            
            # Get content for export (re-converts with color if needed)
            local export_content_arg
            export_content_arg=$(get_export_content "$output_format" "$result" "$resolved_image" \
                "$ARG_WIDTH" "$ARG_HEIGHT" "$palette" "$ARG_INVERT" "$ARG_COLOR" "$ARG_PRESERVE_ASPECT" "$ARG_TRUECOLOR")
            
            export_content "$output_format" "$export_content_arg" "$out_file" "$ARG_BACKGROUND"
            
            if [[ "$ARG_QUIET" != "true" ]]; then
                log_success "Saved to: $out_file"
            fi
        elif [[ -n "$ARG_OUTPUT" ]]; then
            # Auto-detect format from output file extension if format is default
            if [[ "$ARG_FORMAT" == "text" ]]; then
                local detected_format
                detected_format=$(export_detect_format "$ARG_OUTPUT")
                if [[ "$detected_format" != "text" ]]; then
                    output_format="$detected_format"
                fi
            fi
            
            # Get content for export (re-converts with color if needed)
            local export_content_arg
            export_content_arg=$(get_export_content "$output_format" "$result" "$resolved_image" \
                "$ARG_WIDTH" "$ARG_HEIGHT" "$palette" "$ARG_INVERT" "$ARG_COLOR" "$ARG_PRESERVE_ASPECT" "$ARG_TRUECOLOR")
            
            if [[ $total_images -gt 1 ]]; then
                # Batch mode: append with separator (only for text/ansi)
                if [[ "$output_format" =~ $RE_TEXT_FORMAT ]]; then
                    {
                        echo ""
                        echo "# ============ $(basename "$image") ============"
                        echo ""
                        if [[ "$output_format" == "text" ]]; then
                            echo -e "$export_content_arg" | sed 's/\x1b\[[0-9;]*m//g'
                        else
                            echo -e "$export_content_arg"
                        fi
                    } >> "$ARG_OUTPUT"
                else
                    log_warn "Batch mode with multiple images only supports text/ansi formats"
                    export_content "$output_format" "$export_content_arg" "$ARG_OUTPUT" "$ARG_BACKGROUND"
                fi
            else
                export_content "$output_format" "$export_content_arg" "$ARG_OUTPUT" "$ARG_BACKGROUND"
            fi
            
            if [[ "$ARG_QUIET" != "true" && $total_images -eq 1 ]]; then
                log_success "Saved to: $ARG_OUTPUT"
            fi
        else
            # Print to stdout
            if [[ $total_images -gt 1 ]]; then
                echo ""
                echo "# ============ $(basename "$image") ============"
            fi
            echo ""
            echo -e "$result"
            echo ""
        fi
    done
    
    # Batch summary
    if [[ "$ARG_QUIET" != "true" && $total_images -gt 1 ]]; then
        echo ""
        if [[ $failed -eq 0 ]]; then
            log_success "Completed: $processed images processed successfully"
        else
            log_warn "Completed: $((processed - failed))/$processed successful, $failed failed"
            for f in "${failed_files[@]}"; do
                echo "  - $f"
            done
        fi
        if [[ -n "$ARG_OUTPUT" ]]; then
            log_success "All output saved to: $ARG_OUTPUT"
        fi
    fi
}

# ============================================================================
# Entry Point
# ============================================================================

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
