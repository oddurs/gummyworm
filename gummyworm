#!/usr/bin/env bash
#
#  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—
# â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘
# â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘
# â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
# â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘
#  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•     â•šâ•â•   â•šâ•â•    â•šâ•â•â•â•šâ•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•
#
# GUMMYWORM - Transform images into glorious ASCII art!
# 
# A playful, feature-rich image-to-ASCII converter
# Inspired by TheZoraiz/ascii-image-converter
# 
# Author: Claude & Human Collaborator
# License: MIT
# Version: 2.0.0
#
# Dependencies: ImageMagick (convert command)
#
# Usage: gummyworm [OPTIONS] <image_file>
#
# Examples:
#   gummyworm photo.jpg                    # Basic conversion
#   gummyworm -w 80 -c photo.png           # 80 chars wide, colored
#   gummyworm -b --dither photo.png        # Braille mode with dithering
#   gummyworm -i -p blocks photo.gif       # Inverted, block characters
#   gummyworm --full photo.jpg             # Fit terminal width
#

set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION & DEFAULTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

VERSION="2.0.0"
SCRIPT_NAME=$(basename "$0")

# Default settings
DEFAULT_WIDTH=80
DEFAULT_HEIGHT=0  # 0 means auto-calculate from aspect ratio
DEFAULT_PALETTE="standard"
DEFAULT_INVERT=false
DEFAULT_COLOR=false
DEFAULT_GRAYSCALE=false
DEFAULT_OUTPUT=""
DEFAULT_BRAILLE=false
DEFAULT_DITHER=false
DEFAULT_THRESHOLD=128
DEFAULT_FLIP_X=false
DEFAULT_FLIP_Y=false
DEFAULT_NEGATIVE=false
DEFAULT_FULL=false
DEFAULT_COLOR_BG=false

# Character palettes (from darkest to lightest)
declare -A PALETTES=(
    ["standard"]=" .:-=+*#%@"
    ["detailed"]=" .'Â°\`^\",:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@\$"
    ["simple"]=" .oO@"
    ["blocks"]=" â–‘â–’â–“â–ˆ"
    ["binary"]=" â–ˆ"
    ["dots"]=" â â ƒâ ‡â ¿â£¿"
    ["shades"]=" â–‘â–’â–“â–ˆâ–“â–’â–‘"
    ["emoji"]="  ğŸŒ‘ğŸŒ’ğŸŒ“ğŸŒ”ğŸŒ•"
    ["stars"]=" Â·âœ¦â˜…âœ·âœ¸âœ¹"
    ["hearts"]=" â™¡â™¥â¤ğŸ’–ğŸ’—"
    ["matrix"]=" 01"
    ["retro"]=" .:â–‘â–’â–“â–ˆ"
)

# Braille character map (Unicode braille patterns U+2800 to U+28FF)
# Each braille character represents a 2x4 dot matrix
# Dot positions:  1 4
#                 2 5
#                 3 6
#                 7 8

# ANSI color codes
declare -A COLORS=(
    ["reset"]="\033[0m"
    ["bold"]="\033[1m"
    ["red"]="\033[31m"
    ["green"]="\033[32m"
    ["yellow"]="\033[33m"
    ["blue"]="\033[34m"
    ["magenta"]="\033[35m"
    ["cyan"]="\033[36m"
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HELPER FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print_color() {
    local color="$1"
    shift
    echo -e "${COLORS[$color]}$*${COLORS[reset]}"
}

print_error() {
    echo -e "${COLORS[red]}âœ– Error:${COLORS[reset]} $*" >&2
}

print_success() {
    echo -e "${COLORS[green]}âœ”${COLORS[reset]} $*"
}

print_info() {
    echo -e "${COLORS[cyan]}â„¹${COLORS[reset]} $*"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# USAGE & HELP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_banner() {
    cat << 'EOF'
    
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—
 â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘
 â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘
 â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
 â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘
  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•     â•šâ•â•   â•šâ•â•    â•šâ•â•â•â•šâ•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•

    ğŸ› Transform images into glorious ASCII art! ğŸ›
    
EOF
}

show_help() {
    show_banner
    cat << EOF
${COLORS[bold]}USAGE:${COLORS[reset]}
    $SCRIPT_NAME [OPTIONS] <image_file>

${COLORS[bold]}OPTIONS:${COLORS[reset]}
    -w, --width <N>       Output width in characters (default: $DEFAULT_WIDTH)
    -h, --height <N>      Output height in lines (default: auto)
    -p, --palette <NAME>  Character palette to use (default: $DEFAULT_PALETTE)
    -c, --color           Enable ANSI color output
    -i, --invert          Invert brightness (dark â†” light)
    -o, --output <FILE>   Save output to file instead of stdout
    -l, --list-palettes   Show available character palettes
    -q, --quiet           Suppress info messages
    --no-aspect           Don't preserve aspect ratio
    --help                Show this help message
    --version             Show version information

${COLORS[bold]}EXAMPLES:${COLORS[reset]}
    ${COLORS[cyan]}# Basic conversion${COLORS[reset]}
    $SCRIPT_NAME photo.jpg

    ${COLORS[cyan]}# Colored output, 100 characters wide${COLORS[reset]}
    $SCRIPT_NAME -c -w 100 landscape.png

    ${COLORS[cyan]}# Use block characters, inverted${COLORS[reset]}
    $SCRIPT_NAME -p blocks -i portrait.jpg

    ${COLORS[cyan]}# Emoji mode! Perfect for the modern age${COLORS[reset]}
    $SCRIPT_NAME -p emoji sunset.png

    ${COLORS[cyan]}# Save to file${COLORS[reset]}
    $SCRIPT_NAME -o art.txt -w 120 image.jpg

${COLORS[bold]}SUPPORTED FORMATS:${COLORS[reset]}
    JPEG, PNG, GIF, BMP, TIFF, WebP, and any format supported by ImageMagick

${COLORS[bold]}PRO TIPS:${COLORS[reset]}
    ğŸ¨ Use --color for terminal display, omit for plain text files
    ğŸ“ Wider outputs = more detail (try -w 120 or -w 200)
    ğŸŒ™ Use --invert for images with dark backgrounds
    ğŸ”² The 'blocks' palette looks great for high-contrast images
    ğŸ˜º Try 'emoji' palette for fun social media posts!

EOF
}

show_version() {
    echo "$SCRIPT_NAME version $VERSION"
    echo "A playful image-to-ASCII converter"
}

show_palettes() {
    show_banner
    echo -e "${COLORS[bold]}Available Character Palettes:${COLORS[reset]}\n"
    
    for name in $(echo "${!PALETTES[@]}" | tr ' ' '\n' | sort); do
        local chars="${PALETTES[$name]}"
        printf "  ${COLORS[cyan]}%-12s${COLORS[reset]} â”‚ %s â”‚ (%d chars)\n" \
            "$name" "$chars" "${#chars}"
    done
    
    echo ""
    echo -e "${COLORS[bold]}Custom Palettes:${COLORS[reset]}"
    echo "  You can also pass a custom string of characters:"
    echo -e "  ${COLORS[cyan]}$SCRIPT_NAME -p \" .oO0@\" image.jpg${COLORS[reset]}"
    echo ""
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CORE CONVERSION FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

check_dependencies() {
    if ! command -v convert &> /dev/null; then
        print_error "ImageMagick is required but not installed."
        echo "  Install with: sudo apt install imagemagick"
        exit 1
    fi
}

validate_image() {
    local image="$1"
    
    if [[ ! -f "$image" ]]; then
        print_error "File not found: $image"
        exit 1
    fi
    
    if ! identify "$image" &> /dev/null; then
        print_error "Not a valid image file: $image"
        exit 1
    fi
}

get_image_dimensions() {
    local image="$1"
    identify -format "%w %h" "$image" 2>/dev/null
}

# Convert a single pixel's grayscale value to a character
value_to_char() {
    local value="$1"
    local palette="$2"
    local invert="$3"
    local palette_len="${#palette}"
    
    if [[ "$invert" == "true" ]]; then
        value=$((255 - value))
    fi
    
    # Map 0-255 to palette index
    local index=$(( (value * (palette_len - 1)) / 255 ))
    
    # Handle multi-byte characters (like emoji)
    local chars=()
    while IFS= read -r -n1 char; do
        [[ -n "$char" ]] && chars+=("$char")
    done <<< "$palette"
    
    # For simple ASCII, just use substring
    if [[ "$palette_len" -eq "${#palette}" ]] && [[ ! "$palette" =~ [^[:ascii:]] ]]; then
        echo -n "${palette:$index:1}"
    else
        # For unicode/emoji, we need to handle differently
        local i=0
        local result=""
        while [[ $i -lt ${#palette} ]]; do
            local char="${palette:$i:1}"
            # Check if this might be a multi-byte character
            if [[ $(printf '%d' "'$char" 2>/dev/null || echo 0) -gt 127 ]] || [[ "$char" =~ [^[:ascii:]] ]]; then
                # Try to grab the full unicode character
                local full_char=""
                local j=$i
                while [[ $j -lt ${#palette} ]]; do
                    full_char="${palette:$i:$((j-i+1))}"
                    ((j++))
                    # Check if we have a complete character
                    if [[ $(echo -n "$full_char" | wc -m) -eq 1 ]] 2>/dev/null; then
                        break
                    fi
                done
                if [[ ${#result} -eq $index ]]; then
                    echo -n "$full_char"
                    return
                fi
                result+="x"
                i=$j
            else
                if [[ ${#result} -eq $index ]]; then
                    echo -n "$char"
                    return
                fi
                result+="x"
                ((i++))
            fi
        done
    fi
}

# Get ANSI color code for RGB value
rgb_to_ansi() {
    local r="$1" g="$2" b="$3"
    
    # Convert to 256-color palette
    # For simplicity, use the 6x6x6 color cube (colors 16-231)
    local r_idx=$(( (r * 5) / 255 ))
    local g_idx=$(( (g * 5) / 255 ))
    local b_idx=$(( (b * 5) / 255 ))
    
    local color_code=$(( 16 + (r_idx * 36) + (g_idx * 6) + b_idx ))
    
    echo -n "\033[38;5;${color_code}m"
}

# Main conversion function
convert_to_ascii() {
    local image="$1"
    local width="$2"
    local height="$3"
    local palette="$4"
    local invert="$5"
    local use_color="$6"
    local preserve_aspect="$7"
    
    # Get original dimensions
    read -r orig_width orig_height <<< "$(get_image_dimensions "$image")"
    
    # Calculate dimensions
    if [[ "$height" -eq 0 ]]; then
        if [[ "$preserve_aspect" == "true" ]]; then
            # Terminal characters are roughly 2:1 (height:width), so adjust
            height=$(( (width * orig_height * 10) / (orig_width * 22) ))
            [[ "$height" -lt 1 ]] && height=1
        else
            height=$((width / 2))
        fi
    fi
    
    # Create temporary file for pixel data
    local tmpfile
    tmpfile=$(mktemp)
    trap "rm -f '$tmpfile'" EXIT
    
    # Convert image to raw pixel data
    # Resize, ensure 8-bit depth, and output as text pixel values
    convert "$image" \
        -resize "${width}x${height}!" \
        -depth 8 \
        -colorspace sRGB \
        txt:- 2>/dev/null | tail -n +2 > "$tmpfile"
    
    local output=""
    local current_y=-1
    
    # Build palette character array
    # For pure ASCII, use bash substring. For unicode, use python or pre-extract
    local -a palette_chars
    local palette_len
    
    if [[ "$palette" =~ ^[[:ascii:]]*$ ]]; then
        # Pure ASCII - simple
        palette_len=${#palette}
        for ((i=0; i<palette_len; i++)); do
            palette_chars[i]="${palette:$i:1}"
        done
    else
        # Unicode - extract all characters at once using python
        if command -v python3 &>/dev/null; then
            while IFS= read -r char; do
                palette_chars+=("$char")
            done < <(python3 -c "
import sys
for c in sys.argv[1]:
    print(c)
" "$palette")
            palette_len=${#palette_chars[@]}
        else
            # Fallback: use bytes (may not render correctly for unicode)
            palette_len=${#palette}
            for ((i=0; i<palette_len; i++)); do
                palette_chars[i]="${palette:$i:1}"
            done
        fi
    fi
    
    # Process each pixel
    while IFS= read -r line; do
        # Parse pixel data: "X,Y: (R,G,B,A)  #RRGGBB  colorname"
        if [[ "$line" =~ ^([0-9]+),([0-9]+):.*\(([0-9]+),([0-9]+),([0-9]+) ]]; then
            local x="${BASH_REMATCH[1]}"
            local y="${BASH_REMATCH[2]}"
            local r="${BASH_REMATCH[3]}"
            local g="${BASH_REMATCH[4]}"
            local b="${BASH_REMATCH[5]}"
            
            # New line?
            if [[ "$y" -ne "$current_y" ]]; then
                [[ "$current_y" -ge 0 ]] && output+="\n"
                current_y="$y"
                [[ "$use_color" == "true" ]] && output+="\033[0m"
            fi
            
            # Calculate brightness (luminance formula)
            local brightness=$(( (r * 299 + g * 587 + b * 114) / 1000 ))
            
            # Apply inversion
            if [[ "$invert" == "true" ]]; then
                brightness=$((255 - brightness))
            fi
            
            # Map to character
            local char_index=$(( (brightness * (palette_len - 1)) / 255 ))
            # Ensure index is in bounds
            [[ $char_index -ge $palette_len ]] && char_index=$((palette_len - 1))
            [[ $char_index -lt 0 ]] && char_index=0
            
            local char="${palette_chars[$char_index]}"
            
            # Add color if enabled
            if [[ "$use_color" == "true" ]]; then
                output+="$(rgb_to_ansi "$r" "$g" "$b")$char"
            else
                output+="$char"
            fi
        fi
    done < "$tmpfile"
    
    # Reset color at end
    [[ "$use_color" == "true" ]] && output+="\033[0m"
    
    echo -e "$output"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN PROGRAM
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main() {
    # Check dependencies first
    check_dependencies
    
    # Parse arguments
    local width="$DEFAULT_WIDTH"
    local height="$DEFAULT_HEIGHT"
    local palette_name="$DEFAULT_PALETTE"
    local palette=""
    local invert="$DEFAULT_INVERT"
    local use_color="$DEFAULT_COLOR"
    local output_file="$DEFAULT_OUTPUT"
    local preserve_aspect="true"
    local quiet="false"
    local image=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -w|--width)
                width="$2"
                shift 2
                ;;
            -h|--height)
                height="$2"
                shift 2
                ;;
            -p|--palette)
                palette_name="$2"
                shift 2
                ;;
            -c|--color)
                use_color="true"
                shift
                ;;
            -i|--invert)
                invert="true"
                shift
                ;;
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -l|--list-palettes)
                show_palettes
                exit 0
                ;;
            -q|--quiet)
                quiet="true"
                shift
                ;;
            --no-aspect)
                preserve_aspect="false"
                shift
                ;;
            --help)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
            *)
                if [[ -z "$image" ]]; then
                    image="$1"
                else
                    print_error "Multiple images specified. Process one at a time."
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Check if image was provided
    if [[ -z "$image" ]]; then
        show_help
        exit 1
    fi
    
    # Validate image
    validate_image "$image"
    
    # Resolve palette
    if [[ -n "${PALETTES[$palette_name]:-}" ]]; then
        palette="${PALETTES[$palette_name]}"
    else
        # Assume it's a custom palette string
        palette="$palette_name"
    fi
    
    # Validate palette
    if [[ -z "$palette" || ${#palette} -lt 2 ]]; then
        print_error "Palette must have at least 2 characters"
        exit 1
    fi
    
    # Show info
    if [[ "$quiet" != "true" ]]; then
        read -r orig_w orig_h <<< "$(get_image_dimensions "$image")"
        print_info "Converting: $(basename "$image") (${orig_w}x${orig_h})"
        print_info "Output size: ${width} chars wide"
        [[ "$use_color" == "true" ]] && print_info "Color mode: enabled ğŸ¨"
        [[ "$invert" == "true" ]] && print_info "Inverted: yes"
    fi
    
    # Do the conversion
    local result
    result=$(convert_to_ascii "$image" "$width" "$height" "$palette" "$invert" "$use_color" "$preserve_aspect")
    
    # Output
    if [[ -n "$output_file" ]]; then
        # Strip ANSI codes if saving to file (unless it's color output intended for terminal)
        if [[ "$use_color" == "true" ]]; then
            echo -e "$result" > "$output_file"
        else
            echo -e "$result" | sed 's/\x1b\[[0-9;]*m//g' > "$output_file"
        fi
        if [[ "$quiet" != "true" ]]; then
            print_success "Saved to: $output_file"
        fi
    else
        echo ""
        echo -e "$result"
        echo ""
    fi
}

# Run main if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
